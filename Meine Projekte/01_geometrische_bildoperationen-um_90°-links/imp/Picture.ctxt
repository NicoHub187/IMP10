#BlueJ class context
comment0.target=Picture
comment0.text=\r\n\r\n\ Bildklasse\ fuer\ die\ Simulation\ von\ Processing-Befehlen\r\n\ \r\n\ Diese\ Klasse\ stellt\ ein\ BufferedImage\ bereit,\ in\ das\ mit\ Processing-Befehlen\ gezeichnet\r\n\ werden\ kann.\ \r\n\ Zusaetzlich\ kann\ ein\ Bildanzeiger\ ueber\ jede\ Aenderung\ des\ Bildes\ informiert\ werden,\r\n\ um\ "Zurueck"-Befehle\ zu\ ermoeglichen.\ Der\ Bildanzeiger\ ist\ entweder\ eine\ normale\ Java\r\n\ ScrollPane\ oder\ ein\ Actor\ aus\ Greenfoot.\r\n\ Die\ Dokumentation\ der\ einzelnen\ Zeichenmethoden\ ist\ der\ Processing-Reference\ \r\n\ (https\://processing.org/reference/\ steht\ unter\ CC-Lizenz\:\ https\://creativecommons.org/)\ \r\n\ entnommen\ und\ mit\ Deepl.com\ ins\ Deutsche\ uebersetzt.\r\n\r\n\ @version\ 1.2\ from\ 06.12.2019\r\n\ @author\ Thomas\ Schaller\ (ZPG\ Informatik\ Klasse\ 9)\r\n
comment1.params=
comment1.target=Picture()
comment1.text=\ \r\n\ Erzeugt\ ein\ Bild\ mit\ Standardgroesse\ 500x400\r\n
comment10.params=observer
comment10.target=void\ setObserver(PictureViewer)
comment10.text=\ \r\n\ Legt\ fest,\ wer\ das\ Bild\ anzeigt.\r\n\ Diese\ ermoeglicht\ die\ Benachrichtung\ des\ Observers,\ wenn\ sich\ das\ Bild\ aendert.\r\n\ @param\ observer\ Anzeiger\ des\ Bildes\r\n
comment11.params=
comment11.target=PictureViewer\ getObserver()
comment12.params=b
comment12.target=void\ setImage(java.awt.image.BufferedImage)
comment12.text=\ \r\n\ Direktes\ Setzen\ des\ Bildes\ (fuer\ interne\ Zwecke)\r\n\ @param\ b\ Bild,\ das\ gespeichert\ werden\ soll.\r\n
comment13.params=
comment13.target=java.awt.image.BufferedImage\ getImage()
comment13.text=\ \r\n\ Direktes\ Abfragen\ des\ Bildes\ (fuer\ interne\ Zwecke)\r\n\ @return\ Bild,\ das\ gerade\ gespeichert\ ist.\r\n
comment14.params=width\ height
comment14.target=void\ size(int,\ int)
comment14.text=\r\n\ Definiert\ die\ Dimension\ der\ Breite\ und\ Hoehe\ des\ Anzeigefensters\ in\ Pixeleinheiten.\ \r\n\ Die\ eingebauten\ Variablen\ Breite\ und\ Hoehe\ werden\ durch\ die\ an\ diese\ Funktion\ uebergebenen\ Parameter\ festgelegt.\ So\ weist\ beispielsweise\ \r\n\ der\ Befehl\ size(640,\ 480)\ der\ Variablen\ Breite\ 640\ und\ der\ Variablen\ Hoehe\ 480\ zu.\ \r\n\ @param\ width\ Breite\ des\ Bildes\r\n\ @param\ height\ Hoehe\ des\ Bildes\r\n
comment15.params=
comment15.target=int\ getWidth()
comment15.text=\ \r\n\ Liefert\ die\ Breite\ des\ Bildes\ zurueck.\r\n\ @return\ Breite\ des\ Bildes\r\n
comment16.params=
comment16.target=int\ getHeight()
comment16.text=\ \r\n\ Liefert\ die\ Hoehe\ des\ Bildes\ zurueck.\r\n\ @return\ Hoehe\ des\ Bildes\r\n
comment17.params=
comment17.target=void\ pushImage()
comment17.text=\r\n\ Erzeugt\ eine\ Kopie\ des\ Bildes\ und\ uebergibt\ sie\ an\ den\ Observer\ (falls\ existent),\ damit\ dieser\ die\ Versionen\ speichern\ kann\r\n
comment18.params=titel
comment18.target=void\ setTitle(java.lang.String)
comment19.params=autoRefresh
comment19.target=void\ setAutoRefresh(boolean)
comment19.text=\r\n\ Legt\ fest,\ ob\ nach\ jedem\ Zeichenbefehl\ automatisch\ das\ Bild\ auch\ in\r\n\ der\ Oberflaeche\ aktualisiert\ wird.\ Die\ Einstellung\ "false"\ beschleunigt\r\n\ das\ Zeichnen\ aufwaendiger\ Bilder\ und\ verhindert\ "Flackern".\r\n\ Das\ Neuzeichnen\ kann\ durch\ die\ Methode\ "refresh"\ gezielt\ ausgeloest\ werden.\r\n\ @param\ autorefresh\ true\ \=\ nach\ jedem\ Zeichenbefehl\ die\ Anzeige\ aktualisieren,\ false\=\ nur\ durch\ die\ Methode\ refresh\ neu\ zeichnen\r\n
comment2.params=width\ height
comment2.target=Picture(int,\ int)
comment2.text=\r\n\ Erzeugt\ ein\ Bild\ der\ angegeben\ Groesse\r\n\ @param\ width\ Breite\ des\ Bildes\r\n\ @param\ height\ Hoehe\ des\ Bildes\r\n
comment20.params=
comment20.target=void\ repaint()
comment20.text=\r\n\ Auch\ die\ anzeigenden\ Klasse\ wird\ zum\ Neuzeichnen\ aufgefordert.\r\n
comment21.params=
comment21.target=void\ forceRepaint()
comment21.text=\r\n\ Ein\ repaint()\ (das\ Neuzeichnen)\ kann\ manuell\ erzwungen\ werden.\r\n
comment22.params=
comment22.target=void\ clear()
comment22.text=\ \r\n\ Loescht\ den\ Inhalt\ des\ Bildes.\r\n\ Der\ Hintergrund\ wird\ mit\ der\ Hintergrundfarbe\ neu\ gefuellt.\r\n
comment23.params=coord\ mode
comment23.target=void\ convert(int[],\ int)
comment23.text=\ \r\n\ Konvertiert\ die\ in\ einem\ bestimmten\ Modus\ gegebenen\ Koordinaten\ in\ die\ Java-uebliche\ Links_Oben_Breite_Hoehe\ Version\r\n\ Die\ Aenderungen\ werden\ direkt\ im\ Array\ vorgenommen\r\n\ @param\ coord\ Array\ mit\ vier\ Koordinateneintraegen\ im\ gegebenen\ Modus\r\n\ @param\ mode\ \ Modus\ der\ Koordinaten\ (CORNER,\ CORNERS,\ RADIUS\ oder\ CENTER)\r\n
comment24.params=mode
comment24.target=void\ rectMode(int)
comment24.text=\r\n\ Aendert\ den\ Koordinaten-Modus\ beim\ Zeichnen\ von\ Rechtecken.\r\n\ Aendert\ die\ Position,\ von\ der\ aus\ Rechtecke\ gezeichnet\ werden,\ indem\ es\ die\ Art\ und\ Weise\ aendert,\ wie\ Parameter,\ die\ an\ rect()\ uebergeben\ werden,\ interpretiert\ werden.\r\n\ Der\ Standardmodus\ ist\ rectMode(Bild.CORNER),\ der\ die\ ersten\ beiden\ Parameter\ von\ rect()\ als\ die\ linke\ obere\ Ecke\ der\ Form\ interpretiert,\ \r\n\ waehrend\ der\ dritte\ und\ vierte\ Parameter\ seine\ Breite\ und\ Hoehe\ sind.\r\n\ rectMode(Bild.CORNERS)\ interpretiert\ die\ ersten\ beiden\ Parameter\ von\ rect()\ als\ die\ Position\ einer\ Ecke\ \r\n\ und\ die\ dritten\ und\ vierten\ Parameter\ als\ die\ Position\ der\ gegenueberliegenden\ Ecke.\r\n\ rectMode(Bild.CENTER)\ interpretiert\ die\ ersten\ beiden\ Parameter\ von\ rect()\ als\ Mittelpunkt\ der\ Form,\ \r\n\ waehrend\ der\ dritte\ und\ vierte\ Parameter\ seine\ Breite\ und\ Hoehe\ sind.\r\n\ rectMode(RADIUS)\ verwendet\ auch\ die\ ersten\ beiden\ Parameter\ von\ rect()\ als\ Mittelpunkt\ der\ Form,\ \r\n\ verwendet\ aber\ den\ dritten\ und\ vierten\ Parameter,\ um\ die\ Haelfte\ der\ Breite\ und\ Hoehe\ der\ Formen\ festzulegen.\r\n\ @param\ mode\ Modus\ der\ Koordinateninterpretation\ (CORNER,\ CORNERS,\ CENTER\ oder\ RADIUS)\r\n
comment25.params=mode
comment25.target=void\ ellipseMode(int)
comment25.text=\r\n\ Aendert\ den\ Koordinaten-Modus\ beim\ Zeichnen\ von\ Kreisen/Ellipsen.\r\n\ Aendert\ die\ Position,\ von\ der\ aus\ Kreise/Ellipsen\ gezeichnet\ werden,\ indem\ es\ die\ Art\ und\ Weise\ aendert,\ wie\ Parameter,\ die\ an\ ellipse()\ uebergeben\ werden,\ interpretiert\ werden.\r\n\ Der\ Standardmodus\ ist\ ellipseMode(Bild.CENTER),\ der\ die\ ersten\ beiden\ Parameter\ von\ ellipse()\ als\ Mittelpunkt\ der\ Form\ interpretiert,\ \r\n\ waehrend\ der\ dritte\ und\ vierte\ Parameter\ seine\ Breite\ und\ Hoehe\ sind.\r\n\ ellipseMode(Bild.CORNER)\ interpretiert\ die\ ersten\ beiden\ Parameter\ von\ ellipse()\ als\ die\ Position\ einer\ Ecke\ \r\n\ und\ die\ dritten\ und\ vierten\ Parameter\ als\ Breite\ und\ Hoehe\ der\ Form.\r\n\ ellipseMode(Bild.CORNERS)\ interpretiert\ die\ ersten\ beiden\ Parameter\ von\ ellipse()\ als\ die\ Position\ einer\ Ecke\ \r\n\ und\ die\ dritten\ und\ vierten\ Parameter\ als\ die\ Position\ der\ gegenueberliegenden\ Ecke.\r\n\ ellipseMode(RADIUS)\ verwendet\ auch\ die\ ersten\ beiden\ Parameter\ von\ ellipse()\ als\ Mittelpunkt\ der\ Form,\ \r\n\ verwendet\ aber\ den\ dritten\ und\ vierten\ Parameter,\ um\ die\ Haelfte\ der\ Breite\ und\ Hoehe\ der\ Formen\ festzulegen.\r\n\ @param\ mode\ Modus\ der\ Koordinateninterpretation\ (CORNER,\ CORNERS,\ CENTER\ oder\ RADIUS)\r\n
comment26.params=x1\ y1\ x2\ y2
comment26.target=void\ line(int,\ int,\ int,\ int)
comment26.text=\r\n\ Zeichnet\ eine\ Linie\ (einen\ direkten\ Weg\ zwischen\ zwei\ Punkten)\ auf\ den\ Bildschirm.\ \r\n\ Um\ eine\ Linie\ einzufaerben,\ verwenden\ Sie\ die\ {@link\ \#stroke(int,\ int,\ int)\ stroke()}\ Funktion.\ Eine\ Zeile\ kann\ nicht\ gefuellt\ werden,\ daher\ hat\ die\ Funktion\ fill()\ keinen\ \r\n\ Einfluss\ auf\ die\ Farbe\ einer\ Zeile.\ Linien\ werden\ standardmaessig\ mit\ einer\ Breite\ von\ einem\ Pixel\ gezeichnet,\ dies\ kann\ jedoch\ mit\ der\ Funktion\ \r\n\ {@link\ \#strokeWeight(double)\ strokeWeight()}\ geaendert\ werden.\r\n\ @param\ x1\ x-Koordinate\ des\ 1.\ Punktes\r\n\ @param\ y1\ y-Koordinate\ des\ 1.\ Punktes\r\n\ @param\ x2\ x-Koordinate\ des\ 2.\ Punktes\r\n\ @param\ y2\ y-Koordinate\ des\ 2.\ Punktes\r\n
comment27.params=a\ b\ c\ d
comment27.target=void\ rect(int,\ int,\ int,\ int)
comment27.text=\r\n\ Zeichnet\ ein\ Rechteck\ auf\ das\ Bild.\ \r\n\ Standardmaessig\ legen\ die\ ersten\ beiden\ Parameter\ die\ Position\ der\ linken\ oberen\ Ecke\ fest,\ der\ dritte\ die\ Breite\ und\ der\ vierte\ die\ Hoehe.\ \r\n\ Die\ Art\ und\ Weise,\ wie\ diese\ Parameter\ interpretiert\ werden,\ kann\ jedoch\ mit\ der\ Funktion\ {@link\ \#rectMode(int)\ rectMode()}\ geaendert\ werden.\r\n\ Durch\ den\ Befehl\ {@link\ \#fill(int,int,int)\ fill()}\ /{@link\ \#noFill()\ noFill()}\ \ kann\ die\ Fuellfarbe\ des\ Rechtecks\ gewaehlt\ werden,\ durch\ {@link\ \#stroke(int,\ int,\ int)\ stroke()}/{@link\ \#noStroke()\ noStroke()}\ \ die\ Rahmenfarbe.\r\n\ @param\ a\ meist\ die\ x-Koordinate\ der\ linken\ oberen\ Ecke\ (kann\ durch\ rectMode()\ geaendert\ werden).\r\n\ @param\ b\ meist\ die\ y-Koordinate\ der\ linken\ oberen\ Ecke\ (kann\ durch\ rectMode()\ geaendert\ werden).\r\n\ @param\ c\ meist\ die\ Breite\ des\ Rechtecks\ (kann\ durch\ rectMode()\ geaendert\ werden).\r\n\ @param\ d\ meist\ die\ Hoehe\ des\ Rechtecks\ (kann\ durch\ rectMode()\ geaendert\ werden).\r\n\ \r\n
comment28.params=a\ b\ c\ d
comment28.target=void\ ellipse(int,\ int,\ int,\ int)
comment28.text=\r\n\ Zeichnet\ eine\ Ellipse/Kreis\ auf\ das\ Bild.\ \r\n\ Standardmaessig\ legen\ die\ ersten\ beiden\ Parameter\ die\ Position\ des\ Mittelpunkts\ fest,\ der\ dritte\ die\ Breite\ und\ der\ vierte\ die\ Hoehe.\ \r\n\ Die\ Art\ und\ Weise,\ wie\ diese\ Parameter\ interpretiert\ werden,\ kann\ jedoch\ mit\ der\ Funktion\ {@link\ \#ellipseMode(int)\ ellipseMode()}\ geaendert\ werden.\r\n\ Durch\ den\ Befehl\ {@link\ \#fill(int,int,int)\ fill()}\ /{@link\ \#noFill()\ noFill()}\ kann\ die\ Fuellfarbe\ des\ Rechtecks\ gewaehlt\ werden,\ durch\ {@link\ \#stroke(int,\ int,\ int)\ stroke()}/{@link\ \#noStroke()\ noStroke()}\ \ die\ Rahmenfarbe.\r\n\ @param\ a\ meist\ die\ x-Koordinate\ des\ Mittelpunkts\ (kann\ durch\ ellipseMode()\ geaendert\ werden).\r\n\ @param\ b\ meist\ die\ y-Koordinate\ des\ Mittelpunkts\ (kann\ durch\ ellipseMode()\ geaendert\ werden).\r\n\ @param\ c\ meist\ die\ Breite\ des\ Rechtecks\ (kann\ durch\ ellipseMode()\ geaendert\ werden).\r\n\ @param\ d\ meist\ die\ Hoehe\ des\ Rechtecks\ (kann\ durch\ ellipseMode()\ geaendert\ werden).\r\n\ \r\n
comment29.params=x1\ y1\ x2\ y2\ x3\ y3
comment29.target=void\ triangle(int,\ int,\ int,\ int,\ int,\ int)
comment29.text=\r\n\ Zeichnet\ ein\ Dreieck\ auf\ das\ Bild.\ \r\n\ Ein\ Dreieck\ ist\ eine\ Ebene,\ die\ durch\ die\ Verbindung\ von\ drei\ Punkten\ entsteht.\ Die\ ersten\ beiden\ Argumente\ spezifizieren\ den\ \r\n\ ersten\ Punkt,\ die\ mittleren\ beiden\ Argumente\ spezifizieren\ den\ zweiten\ Punkt\ und\ die\ letzten\ beiden\ Argumente\ spezifizieren\ den\ dritten\ Punkt.\ \r\n\ Durch\ den\ Befehl\ {@link\ \#fill(int,int,int)\ fill()}\ /{@link\ \#noFill()\ noFill()}\ kann\ die\ Fuellfarbe\ des\ Rechtecks\ gewaehlt\ werden,\ durch\ {@link\ \#stroke(int,\ int,\ int)\ stroke()}/{@link\ \#noStroke()\ noStroke()}\ \ die\ Rahmenfarbe.\r\n\ @param\ x1\ meist\ die\ x-Koordinate\ des\ 1.\ Punkts.\r\n\ @param\ y1\ meist\ die\ y-Koordinate\ des\ 1.\ Punkts.\r\n\ @param\ x2\ meist\ die\ x-Koordinate\ des\ 2.\ Punkts.\r\n\ @param\ y2\ meist\ die\ y-Koordinate\ des\ 2.\ Punkts.\r\n\ @param\ x3\ meist\ die\ x-Koordinate\ des\ 3.\ Punkts.\r\n\ @param\ y3\ meist\ die\ y-Koordinate\ des\ 3.\ Punkts.\r\n
comment3.params=filename
comment3.target=Picture(java.lang.String)
comment3.text=\ \r\n\ Erzeugt\ ein\ Bild\ aus\ einer\ Datei\r\n\ @param\ filename\ Dateiname\ des\ Bildes\r\n
comment30.params=x1\ y1\ x2\ y2\ x3\ y3\ x4\ y4
comment30.target=void\ quad(int,\ int,\ int,\ int,\ int,\ int,\ int,\ int)
comment30.text=\r\n\ Zeichnet\ ein\ Viereck\ auf\ das\ Bild.\ \r\n\ Ein\ Viereck\ ist\ ein\ vierseitiges\ Polygon.\ Es\ ist\ aehnlich\ wie\ ein\ Rechteck,\ aber\ die\ Winkel\ zwischen\ seinen\ Kanten\ \r\n\ sind\ nicht\ auf\ neunzig\ Grad\ beschraenkt.\ Das\ erste\ Paar\ von\ Parametern\ (x1,y1)\ setzt\ den\ ersten\ Scheitelpunkt\ und\ die\ nachfolgenden\ \r\n\ Paare\ sollten\ im\ Uhrzeigersinn\ oder\ gegen\ den\ Uhrzeigersinn\ um\ die\ definierte\ Form\ herum\ verlaufen.\ \r\n\ Durch\ den\ Befehl\ {@link\ \#fill(int,int,int)\ fill()}\ /{@link\ \#noFill()\ noFill()}\ kann\ die\ Fuellfarbe\ des\ Rechtecks\ gewaehlt\ werden,\ durch\ {@link\ \#stroke(int,\ int,\ int)\ stroke()}/{@link\ \#noStroke()\ noStroke()}\ \ die\ Rahmenfarbe.\r\n\ @param\ x1\ meist\ die\ x-Koordinate\ des\ 1.\ Punkts.\r\n\ @param\ y1\ meist\ die\ y-Koordinate\ des\ 1.\ Punkts.\r\n\ @param\ x2\ meist\ die\ x-Koordinate\ des\ 2.\ Punkts.\r\n\ @param\ y2\ meist\ die\ y-Koordinate\ des\ 2.\ Punkts.\r\n\ @param\ x3\ meist\ die\ x-Koordinate\ des\ 3.\ Punkts.\r\n\ @param\ y3\ meist\ die\ y-Koordinate\ des\ 3.\ Punkts.\r\n\ @param\ x4\ meist\ die\ x-Koordinate\ des\ 3.\ Punkts.\r\n\ @param\ y4\ meist\ die\ y-Koordinate\ des\ 3.\ Punkts.\r\n
comment31.params=x\ y
comment31.target=void\ polygon(int[],\ int[])
comment31.text=\r\n\ Zeichnet\ ein\ Polygon\ auf\ das\ Bild.\r\n\ Gleich\ lange\ Listen\ von\ x\ und\ y-Koordinaten\ bestimmen\ die\ Eckpunkte\ des\ Polygons.\r\n\ Durch\ den\ Befehl\ {@link\ \#fill(int,int,int)\ fill()}\ /{@link\ \#noFill()\ noFill()}\ kann\ die\ Fuellfarbe\ des\ Rechtecks\ gewaehlt\ werden,\ durch\ {@link\ \#stroke(int,\ int,\ int)\ stroke()}/{@link\ \#noStroke()\ noStroke()}\ die\ Rahmenfarbe.\r\n\ @param\ x\ Liste\ der\ x-Koordinaten\ der\ Punkte.\r\n\ @param\ y\ Liste\ der\ y-Koordinaten\ der\ Punkte.\r\n
comment32.params=x\ y
comment32.target=void\ point(int,\ int)
comment32.text=\r\n\ Zeichnet\ einen\ Punkt,\ d.h.\ einen\ Kreis\ in\ der\ Dimension\ eines\ Pixels.\ \r\n\ Der\ erste\ Parameter\ ist\ der\ x-Wert\ fuer\ den\ Punkt,\ der\ zweite\ Wert\ ist\ der\ y-Wert\ fuer\ den\ Punkt.\ \r\n\ @param\ x\ x-Koordinate\ des\ Punktes\r\n\ @param\ y\ y-Koordinate\ des\ Punktes\r\n
comment33.params=s\ x\ y
comment33.target=void\ text(java.lang.String,\ int,\ int)
comment33.text=\r\n\ Gibt\ einen\ Text\ an\ den\ gegebenen\ Koordinaten\ aus\r\n\ Zur\ Ausgabe\ des\ Textes\ wird\ der\ ausgewaehlte\ Font\ verwendet.\ Dieser\ muss\ vorher\ mit\ {@link\ \#textFont(Font)\ textFont()\ }\ festgelegt.\r\n\ @param\ s\ Text,\ der\ angezeigt\ werden\ soll\r\n\ @param\ x\ x-Koordinate\ des\ Textanfangs\r\n\ @param\ y\ y-Koordinate\ der\ Grundlinie\ des\ Textes.\r\n
comment34.params=font
comment34.target=void\ textFont(java.awt.Font)
comment34.text=\r\n\ Legt\ die\ Schriftart\ fuer\ Textausgaben\ fest.\r\n\ Jeder\ uebliche\ Java-Font\ kann\ verwendet\ werden.\ Er\ kann\ mit\ z.B.\ Font\ f\ \=\ new\ Font(\ "Arial",\ Font.PLAIN,\ 14\ );\ definiert\ werden.\ \r\n\ @param\ font\ ein\ Font-Objekt\ \r\n
comment35.params=color
comment35.target=java.awt.Color\ decode(java.lang.String)
comment35.text=\ \r\n\ Hilfsfunktion\ zur\ Interpretation\ von\ Farben\r\n
comment36.params=color
comment36.target=java.awt.Color\ decode(int)
comment36.text=\ \r\n\ Hilfsfunktion\ zur\ Interpretation\ von\ Farben\r\n
comment37.params=pencolor
comment37.target=void\ stroke(java.lang.String)
comment37.text=\r\n\ Legt\ die\ Farbe\ fest,\ mit\ der\ Linien\ und\ Raender\ um\ Formen\ gezeichnet\ werden.\ \r\n\ Diese\ Farbe\ wird\ hexadezimal\ in\ Form\ der\ RGB\ angegeben\:\ z.B.\ \ "CCFFAA"\ oder\ "004E23".\ Die\ Syntax\ verwendet\ sechs\ Ziffern\ -\ je\ zwei\ fuer\ die\ roten,\ gruenen\ und\ blauen\ Komponenten,\r\n\ um\ eine\ Farbe\ anzugeben\ (genau\ wie\ Farben\ typischerweise\ in\ HTML\ und\ CSS\ angegeben\ werden).\ \r\n\ @param\ pencolor\ Stiftfarbe\ in\ Hexadezimaldarstellung\r\n
comment38.params=pencolor
comment38.target=void\ stroke(int)
comment38.text=\r\n\ Legt\ die\ Farbe\ fest,\ mit\ der\ Linien\ und\ Raender\ um\ Formen\ gezeichnet\ werden.\ \r\n\ Diese\ Farbe\ wird\ entweder\ als\ Graustufe\ (0-255)\ oder\ als\ 3-Byte\ RGB-Wert\ angegeben\r\n\ @param\ pencolor\ Stiftfarbe\ (0-255\:\ Graustufe\ zwischen\ 0\ schwarz\ und\ 255\ weiss,\ sonst\:\ c\ wird\ als\ 3-Byte\ RGB-Wert\ interpretiert)\r\n
comment39.params=r\ g\ b
comment39.target=void\ stroke(int,\ int,\ int)
comment39.text=\r\n\ Legt\ die\ Farbe\ fest,\ mit\ der\ Linien\ und\ Raender\ um\ Formen\ gezeichnet\ werden.\ \r\n\ Diese\ Farbe\ wird\ komponentenweise\ als\ RGB-Wert\ angegeben\r\n\ @param\ r\ Rotanteil\ (0-255)\ der\ Stiftfarbe\r\n\ @param\ g\ Gruenanteil\ (0-255)\ der\ Stiftfarbe\r\n\ @param\ b\ Blauanteil\ (0-255)\ der\ Stiftfarbe\r\n
comment4.params=width\ height\ background
comment4.target=Picture(int,\ int,\ java.lang.String)
comment4.text=\r\n\ Erzeugt\ ein\ Bild\ der\ angegebenen\ Groesse\ mit\ festgelegtem\ Hintergrund\r\n\ @param\ width\ Breite\ des\ Bildes\r\n\ @param\ height\ Hoehe\ des\ Bildes\r\n\ @param\ background\ Farbe\ des\ Hintergrunds\r\n
comment40.params=
comment40.target=void\ noStroke()
comment40.text=\r\n\ Legt\ fest,\ dass\ keine\ Linien\ oder\ Raender\ um\ Formen\ gezeichnet\ werden\ soll.\ \r\n
comment41.params=width
comment41.target=void\ strokeWeight(double)
comment41.text=\r\n\ Legt\ die\ Breite\ des\ Strichs\ fuer\ Linien,\ Punkte\ und\ den\ Rand\ um\ Formen\ fest.\ \r\n\ Alle\ Breiten\ werden\ in\ Pixeleinheiten\ angegeben.\ \r\n\ @param\ width\ Breite\ in\ Pixel\r\n
comment42.params=fillcolor
comment42.target=void\ fill(java.lang.String)
comment42.text=\r\n\ Legt\ die\ Farbe\ fest,\ mit\ der\ Formen\ gefuellt\ werden.\ \r\n\ Diese\ Farbe\ wird\ hexadezimal\ in\ Form\ der\ RGB\ angegeben\:\ z.B.\ \ "CCFFAA"\ oder\ "004E23".\ Die\ Syntax\ verwendet\ sechs\ Ziffern\ -\ je\ zwei\ fuer\ die\ roten,\ gruenen\ und\ blauen\ Komponenten,\r\n\ um\ eine\ Farbe\ anzugeben\ (genau\ wie\ Farben\ typischerweise\ in\ HTML\ und\ CSS\ angegeben\ werden).\ \r\n\ @param\ fillcolor\ Fuellfarbe\ in\ Hexadezimaldarstellung\r\n
comment43.params=fillcolor
comment43.target=void\ fill(int)
comment43.text=\r\n\ Legt\ die\ Farbe\ fest,\ mit\ der\ Formen\ gefuellt\ werden.\r\n\ Diese\ Farbe\ wird\ entweder\ als\ Graustufe\ (0-255)\ oder\ als\ 3-Byte\ RGB-Wert\ angegeben.\r\n\ @param\ fillcolor\ Fuellfarbe\ (0-255\:\ Graustufe\ zwischen\ 0\ schwarz\ und\ 255\ weiss,\ sonst\:\ c\ wird\ als\ 3-Byte\ RGB-Wert\ interpretiert)\r\n
comment44.params=r\ g\ b
comment44.target=void\ fill(int,\ int,\ int)
comment44.text=\r\n\ Legt\ die\ Farbe\ fest,\ mit\ der\ Formen\ gefuellt\ werden.\r\n\ Diese\ Farbe\ wird\ komponentenweise\ als\ RGB-Wert\ angegeben.\r\n\ @param\ r\ Rotanteil\ (0-255)\ der\ Fuellfarbe\r\n\ @param\ g\ Gruenanteil\ (0-255)\ der\ Fuellfarbe\r\n\ @param\ b\ Blauanteil\ (0-255)\ der\ Fuellfarbe\r\n
comment45.params=
comment45.target=void\ noFill()
comment45.text=\ Legt\ fest,\ dass\ die\ Formen\ nicht\ gefuellt\ werden\ sollen.\r\n
comment46.params=c
comment46.target=void\ background(int)
comment46.text=\r\n\ Die\ Funktion\ background()\ setzt\ die\ Farbe,\ die\ fuer\ den\ Hintergrund\ des\ Bildes\ verwendet\ wird.\ Der\ Standardhintergrund\ ist\ hellgrau.\ \r\n\ Es\ ist\ nicht\ moeglich,\ den\ Alpha-Parameter\ Transparenz\ mit\ Hintergrundfarben\ auf\ der\ Hauptzeichnungsoberflaeche\ zu\ verwenden.\ \r\n\ @param\ c\ Farbe\ fuer\ den\ Hintergrund\ (0-255\:\ Graustufe\ zwischen\ 0\ schwarz\ und\ 255\ weiss,\ sonst\:\ c\ wird\ als\ 3-Byte\ RGB-Wert\ interpretiert)\r\n
comment47.params=r\ g\ b
comment47.target=void\ background(int,\ int,\ int)
comment47.text=\r\n\ Die\ Funktion\ background()\ setzt\ die\ Farbe,\ die\ fuer\ den\ Hintergrund\ des\ Bildes\ verwendet\ wird.\ Der\ Standardhintergrund\ ist\ hellgrau.\ \r\n\ Es\ ist\ nicht\ moeglich,\ den\ Alpha-Parameter\ Transparenz\ mit\ Hintergrundfarben\ auf\ der\ Hauptzeichnungsoberflaeche\ zu\ verwenden.\ \r\n\ @param\ r\ Rotanteil\ (0-255)\ der\ Hintergrundfarbe\r\n\ @param\ g\ Gruenanteil\ (0-255)\ der\ Hintergrundfarbe\r\n\ @param\ b\ Blauanteil\ (0-255)\ der\ Hintergrundfarbe\r\n
comment48.params=hex
comment48.target=void\ background(java.lang.String)
comment48.text=\r\n\ Die\ Funktion\ background()\ setzt\ die\ Farbe,\ die\ fuer\ den\ Hintergrund\ des\ Bildes\ verwendet\ wird.\ Der\ Standardhintergrund\ ist\ hellgrau.\ \r\n\ Es\ ist\ nicht\ moeglich,\ den\ Alpha-Parameter\ Transparenz\ mit\ Hintergrundfarben\ auf\ der\ Hauptzeichnungsoberflaeche\ zu\ verwenden.\ \r\n\ @param\ hex\ String\ \ \ \ Farbe\ in\ Hexadezimalangabe\r\n
comment49.params=filename
comment49.target=void\ load(java.lang.String)
comment49.text=\ \r\n\ Laedt\ ein\ Bild\ aus\ dem\ Dateisystem.\r\n\ Laedt\ ein\ Bild\ von\ einem\ Datentraeger\ und\ setzt\ Stiftfarbe\ und\ Fuellfarbe\ auf\ Standardwerte\ zurueck.\r\n\ @param\ filename\ Dateiname\ des\ Bildes\r\n
comment5.params=
comment5.target=void\ showInFrame()
comment50.params=filename
comment50.target=void\ save(java.lang.String)
comment50.text=\ \r\n\ Speichert\ ein\ Bild.\r\n\ Speichert\ ein\ Bild\ auf\ einem\ Datentraeger.\ Zulaessig\ sind\ die\ Dateiformate\ PNG\ und\ GIF.\ Die\ Dateiendung\ legt\ den\ Typ\ fest.\r\n\ Standardmaessig\ wird\ die\ Dateiendung\ .png\ ergaenzt,\ wenn\ keine\ angegeben\ ist.\r\n\ @param\ filename\ Dateiname\ des\ Bildes\r\n
comment51.params=
comment51.target=java.awt.Color[][]\ getPixelArray()
comment51.text=\r\n\ Liefert\ das\ Bild\ als\ zweidimensionales\ Pixel-Array.\r\n\ @return\ zweidimensionales\ Array\ von\ Color-Objekten,\ die\ den\ Pixeln\ des\ Bildes\ entsprechen.\r\n
comment52.params=pixel
comment52.target=void\ setPixelArray(java.awt.Color[][])
comment52.text=\r\n\ Setzt\ das\ Bild\ neu\ auf\ Basis\ des\ Pixel-Arrays.\r\n\ Die\ Groesse\ des\ Bildes\ wird\ nicht\ automatisch\ an\ das\ Array\ angepasst.\r\n\ @param\ pixel\ zweidimensionales\ Array\ von\ Color-Objekten\r\n
comment53.params=millis
comment53.target=void\ delay(int)
comment53.text=\r\n\ Hilfsfunktion\ zum\ Verzoegern\ der\ Ausgabe\r\n\ @param\ millis\ Wartezeit\ in\ Millisekunden\r\n
comment6.params=width\ height
comment6.target=void\ makeImage(int,\ int)
comment7.params=
comment7.target=void\ antialise()
comment8.params=neuerWert
comment8.target=void\ setAntialising(boolean)
comment9.params=
comment9.target=boolean\ isAntialiasing()
numComments=54
